If you assume those lessons were all about learning how to write good code, these next few lessons are going to be about training yourself to figure out the best code to write – the most elegant solution to the problem at hand. It becomes particularly important whenever you start working with large data sets, like when your website becomes highly successful.

# Algorithms:
A set of instructions for solving some problem step by step. Algorithms are everywhhere. 
Algorithms become important in web development when you have a lot of data that you have to process or when you are performing complicated transformations on that data. For example, consider the Quora search engine. You could probably develop a similar search engine without much algorithms experience. However, once your site gained thousands or millions of users, your search engine would not be able to handle the large bandwidth of requests. 
Algorithms let you figure out efficient ways to handle large amounts of data.

Pseudocode is an English way to state an algorithm. 

# Recursion:
Recursion is the idea that a function calls itself. It is used to take on bigger problems and break them down into smaller pieces. Think ## Divide and Conquer ##. 
` In computer science, divide and conquer (D&C) is an important algorithm design paradigm based on multi-branched recursion. A divide and conquer algorithm works by recursively breaking down a problem into two or more sub-problems of the same (or related) type, until these become simple enough to be solved directly. The solutions to the sub-problems are then combined to give a solution to the original problem. `

The fact is, any problem you can solve recursively, you can also solve using the iterators that you know and love. If you find yourself saying “why didn’t I just use a while loop here?” then you probably should have. Some problems also break down into far too many pieces and totally overwhelm your computer’s memory. There’s a balance.

Recursion is a programming pattern that is useful in situations when a task can be naturally split into several tasks of the same kind, but simpler. Or when a task can be simplified into an easy action plus a simpler variant of the same task. Or, as we’ll see soon, to deal with certain data structures. The basis of recursion is function arguments that make the task so simple that the function does not make further calls.
Example: A power function
pow(2, 2) = 4
pow(2, 3) = 8
pow(2, 4) = 16 

function pow(x, n) { // for loop approach
  let result = 1;
  // multiply result by x n times in the loop
  for (let i = 0; i < n; i++) {
    result *= x;
  }
  return result;
}
alert( pow(2, 3) ); // 8

function pow(x, n) { // RECURSIVE APPROACH
  if (n == 1) {
    return x;
  } else {
    return x * pow(x, n - 1);
  }
}
alert( pow(2, 3) ); // 8
AKA
              if n==1  = x
             /
pow(x, n) =
             \
              else     = x * pow(x, n - 1)
1. If n == 1, then everything is trivial. It is called the base of recursion, because it immediately produces the obvious result: pow(x, 1) equals x.
2. Otherwise, we can represent pow(x, n) as x * pow(x, n - 1). In maths, one would write xn = x * xn-1. This is called a recursive step: we transform the task into a simpler action (multiplication by x) and a simpler call of the same task (pow with lower n). Next steps simplify it further and further until n reaches 1.
3. We can also say that pow recursively calls itself till n == 1.
4. For example, to calculate pow(2, 4) the recursive variant does these steps:
pow(2, 4) = 2 * pow(2, 3)
pow(2, 3) = 2 * pow(2, 2)
pow(2, 2) = 2 * pow(2, 1)
pow(2, 1) = 2

It gets simpler and simpler until it gets obvious. Recursion is also usually SHORTER than iterative approaches. 

## Defitiion: RECURSION DEPTH - The maximal number of nested calls (including the first one) 
In this function it will be n. The maximal recursion depth is limited by JavaScript engine. We can rely on it being 10,000, some engines allow more, but 100000 is probably out of limit for the majority of them. There are automatic optimizations that help alleviate this. 

The information about the process of execution of a running function is stored in its "execution context".
Execution context is an internal data structure that contains details about the execution of a function: the control flow, variables, the value of this and some other data. 1 function = 1 execution context. 

When a function makes a nested call, the following happens:
The current function is paused.
The execution context associated with it is remembered in a special data structure called execution context stack. The current context is “remembered” on top of the stack.
The new context is created for the subcall.
The nested call executes.
After it ends, when the subcall is finished – the previous context is popped from the stack, and its execution continues. The old execution context is retrieved from the stack, and the outer function is resumed from where it stopped.

Here’s the context stack when we entered the subcall pow(2, 1):
Context: { x: 2, n: 1, at line 1 } pow(2, 1) - subcall first
Context: { x: 2, n: 2, at line 1 } pow(2, 2) - subcall
Context: { x: 2, n: 3, at line 5 } pow(2, 3) -  first call

The recursion depth in this case was: 3.

### Any recursion can be rewritten as a loop. The loop variant usually can be made more effective.

## Example:
`let company = {
  sales: [{
    name: 'John',
    salary: 1000
  }, {
    name: 'Alice',
    salary: 1600
  }],

  development: {
    sites: [{
      name: 'Peter',
      salary: 2000
    }, {
      name: 'Alex',
      salary: 1800
    }],

    internals: [{
      name: 'Jack',
      salary: 1300
    }]
  }
};`
It is also possible that when a subdepartment grows, it divides into subsubdepartments (or teams). For instance, the sites department in the future may be split into teams for siteA and siteB. And they, potentially, can split even more. That’s not on the picture, just something to have in mind.

### Let’s try recursion. ### 
As we can see, when our function gets a department to sum, there are two possible cases:
Either it’s a “simple” department with an array of people – then we can sum the salaries in a simple loop.
Or it’s an object with N subdepartments – then we can make N recursive calls to get the sum for each of the subdeps and combine the results.
1. The 1st case is the base of recursion, the trivial case, when we get an array.
2. The 2nd case when we get an object is the recursive step. A complex task is split into subtasks for smaller departments. They may in turn split again, but sooner or later the split will finish at (1).

let company = { // the same object, compressed for brevity
  sales: [{name: 'John', salary: 1000}, {name: 'Alice', salary: 1600 }],
  development: {
    sites: [{name: 'Peter', salary: 2000}, {name: 'Alex', salary: 1800 }],
    internals: [{name: 'Jack', salary: 1300}]
  }
};
// The function to do the job
function sumSalaries(department) {
  if (Array.isArray(department)) { // case (1)
    return department.reduce((prev, current) => prev + current.salary, 0); // sum the array
  } else { // case (2)
    let sum = 0;
    for (let subdep of Object.values(department)) {
      sum += sumSalaries(subdep); // recursively call for subdepartments, sum the results
    }
    return sum;
  }
}
alert(sumSalaries(company)); // 7700

We can easily see the principle: for an object {...} subcalls are made, while arrays [...] are the “leaves” of the recursion tree, they give immediate result.

## Linked List:
There’s a big problem with arrays... The “delete element” and “insert element” operations are expensive. For instance, arr.unshift(obj) operation has to renumber all elements to make room for a new obj, and if the array is big, it takes time. Same with arr.shift().
If we really need fast insertion/deletion, we can choose another data structure called a linked list.

## The linked list element is recursively defined as an object with:
- value.
- "next" property referencing the next linked list element or null if that’s the end.
For instance:
let list = {
  value: 1,
  next: {
    value: 2,
    next: {
      value: 3,
      next: {
        value: 4,
        next: null
      }
    }
  }
};

## A recursively-defined data structure is a data structure that can be defined using itself.
list = { value, next -> list }

### Alternative for creation: 
let list = { value: 1 };
list.next = { value: 2 };
list.next.next = { value: 3 };
list.next.next.next = { value: 4 };
list.next.next.next.next = null;

## Another example: 
`let secondList = list.next.next;`
`list.next.next = null;`
- Breaking and Rejoining a List: The sequence of operations demonstrates how you might temporarily break a linked list into two parts and then rejoin them. This could be useful in certain algorithms where a temporary separation of the list is needed, such as reversing a portion of the list, splitting it for parallel processing, or reorganizing nodes.

- Intermediate State: When you set list.next.next = null, the list is temporarily split into two separate lists. One list starts with list and ends at list.next, and the other list starts with secondList.

`list.next.next = secondList;`

- Final State: By setting list.next.next = secondList, you restore the original link, resulting in a single continuous list as it was initially. This pattern is common in linked list operations, where intermediate states are used to facilitate complex manipulations like sorting, merging, or rearranging nodes.


let list = { value: 1 };
list.next = { value: 2 };
list.next.next = { value: 3 };
list.next.next.next = { value: 4 };

// prepend the new value to the list
list = { value: "new item", next: list };

* To remove a value from the middle, change next of the previous one:
list.next = list.next.next;

We made list.next jump over 1 to value 2. The value 1 is now excluded from the chain. If it’s not stored anywhere else, it will be automatically removed from the memory. Unlike arrays, there’s no mass-renumbering, we can easily rearrange elements.
* The main drawback is that we can’t easily access an element by its number. In an array that’s easy: arr[n] is a direct reference. But in the list we need to start from the first item and go next N times to get the Nth element.

## Lists can be enhanced:
- We can add property prev in addition to next to reference the previous element, to move back easily.
- We can also add a variable named tail referencing the last element of the list (and update it when adding/removing elements from the end).
- The data structure may vary according to our needs.

SLICK
function fib(n) {
  let a = 1;
  let b = 1;
  for (let i = 3; i <= n; i++) {
    let c = a + b;
    a = b;
    b = c;
  }
  return b;
}

alert( fib(3) ); // 2
alert( fib(7) ); // 13
alert( fib(77) ); // 5527939700884757


printList(list) {
    if (list.next === null) {
        console.log(list.value) 
    } else {
        console.log(list.value);
        printList(list.next); 
    }
}

reverse a linked list


let list = {
  value: 1,
  next: {
    value: 2,
    next: {
      value: 3,
      next: {
        value: 4,
        next: null
      }
    }
  }
};

function printReverseList(list) {
  if (list.next) {
    printReverseList(list.next);
  }
  alert(list.value);
}
printReverseList(list);


function sumRangeRecursive(n, total = 0) {
    if (n <= 0) {
        return total
    }
    return sumRangeRecursive(n - 1, total + n) 
}
what this does:
sumRangeRecoursive(3, 0)
    sumRangeRecoursive(2, 3)
        sumRangeRecoursive(1, 5)
            sumRangeRecoursive(0, 6)
            return 6
        return 6
    return 6
return 6

The 5 steps to solve any recursive problem:
1. Find the simplest case (base case)
2. Play around with examples and visualize.
3. Relate the harder cases to the simpler cases.
4. Generalize pattern.
5. Combine recursive pattern with base case using code.

function collatzConjecture(n, step = 0) {
    if (n = 1) {
        return step
    } else if (n % 2 === 0) {
        return collatzConjecture((n/2), step + 1)
    } else if (n % 2 !== 0) {
        return collatzConjecture((3n + 1), step + 1)
    }
}

^ this is not necessary to keep track of the step because each recursive situation only adds 1 to the step count

function collatzConjecture(n, step = 0) {
    if (n = 1) {
        return step
    } else if (n % 2 === 0) {
        return 1 + collatzConjecture((n/2))
    } else if (n % 2 !== 0) {
        return 1 + collatzConjecture((3n + 1))
    }
}

# 5 STEPS TO SOLVE ANY RECURSIVE PROBLEM
 - 1. What is the simplest possible input?
 - 2. Play around with examples and visualize. 
 - 3. Relate harder cases to simple cases. 
 - 4. Generalize the pattern
 - 5. Write code by combining the recursive pattern with the base case. 


The first insight is that iteration is a special case of recursion.
        void do_loop () { do { ... } while (e); }
is equivalent to:
        void do_loop () { ... ; if (e) do_loop(); }


* int sumTailRecursive(int n, int accu = 0) { // tail recursive and 
    if (n == 0) return accu;
    return sumTailRecursive(n-1, accu + n);
}
Here, the recursive call sumTailRecursive(n-1, accu + n) is the last operation, making it tail recursive. A compiler can optimize this function to run in constant space.


# MERGE SORT #
 - the main idea is to sort smaller arrays and combine those arrays into the correct order
 - the most complicated type of sort in CS50
 - Sort the left, sort the right, merge the sorted halves together. 
 Merge Sort is just these 3 steps recursively. Dividing and Conquering

 Single elements are sorted by default. What does it mean to merge sorted halves?
 take this example:
 2457 0136
 Compare 2 to 0: which number is less?
 0... now compare 2 to 1? 
 01
 now compare 2 to 3? 
 012
 now compare 4 and 3?
 0123 
 4 and 6?
 01234
 5 and 6?
 012345
 7 and 6?
 0123456
 only 7 left? 01234567

 # QUICK NOTE ON LOGARITHMS #
 Logarithms:
 b^p = n 

 p is the logarithm of n
 log  n = p  ==> b ^ p = n OR b raised to what power = n 
    `b
 log  8 = 3
    `2


### TIME COMPLEXITY ###

