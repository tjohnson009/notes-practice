# Setting Up A React Environment #
There are many ways to start using React in your projects:
Some examples of these toolchains include:
- Vite’s React Config
- Gatsby
- NextJS
- Create React App (Deprecated): Create React App, or CRA, was the official way to scaffold new React projects since its introduction in 2016. Unfortunately, owing to many reasons, CRA was deprecated in early 2023. Due to CRA’s popularity, you’ll see it mentioned in many tutorials and guides. However, it’s no longer recommended to use it for new projects.
NOW we can start up react with a single terminal command
* VITE builds frontend tools for developers and it leverages the latest technologies under the hood to provide a great developer experience. Fortunately, it also caters to the React ecosystem. We will use Vite’s CLI to quickly create a template React project. 

*** npm create vite@latest my-react-app -- --template react ***
THEN: 
cd my-first-react-app
npm install
npm run dev 

If creating a react project in a existing repo:
*** npm create vite@latest . -- --template react ***
This will tell Vite to use the current directory for the project, instead of creating a new directory 
with the given project name. This cloned directory will already be initialized as a git repo and connected to the right remote.

# REACT COMPONENTS #
The beauty of React is that it allows you to break a UI (User Interface) down into independent reusable chunks, which we will refer to as components. 
Think of these reusable chunks as JavaScript functions which can take some kind of input and return a React element.

function Greeting() {
  return <h1>&quot;I swear by my pretty floral bonnet, I will end you.&quot;</h1>;
}
React components return JSX. 
* React components MUST be capitalized or they will not function as expected, which is why we capitalized Greeting().
*** For a very long time in React development, it was necessary to import React in your JavaScript files that used React components, but since React v17.0 it is no longer required. ***

There are different kinds of React components:


# What is JSX? #
JSX is a syntax extension for JavaScript that lets you write HTML-like markup inside a JavaScript file. It’s NOT required to use JSX when writing React components, but it does make writing them more concise.
JSX is syntactic sugar for the React createElement function. JSX compiles down to plain JavaScript objects.
- Rules of JSX:
1. Return a single root element 
function App() {
  // Could replace <></> with <div></div>
  return (
    <> // this is called a React Fragment - single element
    Fragments let you group things without leaving any trace in the browser HTML tree.
      <h1>Example h1</h1>
      <h2>Example h2</h2>
    </>
  );
}
2. Close all tags
function App() {
  return (
    <>
      <input />
      <li></li>
    </>
  );
 }
3. camelCase most tags: JSX turns into JavaScript, and 
* attributes of elements become keys of JavaScript objects, *
so you can’t use dashes or reserved words such as class. Because of this, many HTML attributes are written in camelCase. Instead of stroke-width, you’d use strokeWidth, and instead of class you’d use className.

# JavaScript with Markup #
You can use curly braces in your JSX to open a window to JavaScript. That’s because curly braces let you work with JavaScript right there in your markup!
JSX is a special way of writing JavaScript. That means it’s possible to use JavaScript inside it—with curly braces { }. 
You can only use curly braces in two ways inside JSX:
1. As text directly inside a JSX tag: <h1>{name}'s To Do List</h1> works, but <{tag}>Gregorio Y. Zara's To Do List</{tag}> will not.
2. As attributes immediately following the = sign: src={avatar} will read the avatar variable, but src="{avatar}" will pass the string "{avatar}".

You can pass a JS object in JSX, but you must wrap the object in another pair of curly braces: 
person={{ name: "Hedy Lamarr", inventions: 5 }}.
You may see this with inline CSS styles in JSX. React does not require you to use inline styles (CSS classes work great for most cases). 
But when you need an inline style, you pass an object to the style attribute:
export default function TodoList() {
  return (
    <ul style={{ <--- SEE
      backgroundColor: 'black',
      color: 'pink'
    }}>
      <li>Improve the videophone</li>
      <li>Prepare aeronautics lectures</li>
      <li>Work on the alcohol-fuelled engine</li>
    </ul>
  );
}
The next time you see {{ and }} in JSX, know that it’s nothing more than an object inside the JSX curlies!
*** Inline style properties are written in camelCase. For example, HTML <ul style="background-color: black"> would be written as <ul style={{ backgroundColor: 'black' }}>  in your component. ***

CLEVER:
const person = {
  name: 'Gregorio Y. Zara',
  theme: {
    backgroundColor: 'black',
    color: 'pink'
  }
};

export default function TodoList() {
  return (
    <div style={person.theme}> // applies the styles from person.theme to the element

# Rendering and Conditional Rendering # 
function App() {
  const animals = ["Lion", "Cow", "Snake", "Lizard"];

  return (
    <div>
      <h1>Animals: </h1>
      <ul>
        {animals.map((animal) => { // this can take a list however long we want and render it all as a list
          return <li key={animal}>{animal}</li>;
        })}
      </ul>
    </div>
  );
}
*** JSX has the ability to automatically render arrays, therefore these are the same *** 
function App() {
  const animals = ["Lion", "Cow", "Snake", "Lizard"];
  const animalsList = animals.map((animal) => <li key={animal}>{animal}</li>)

  return (
    <div>
      <h1>Animals: </h1>
      <ul>
        {animalsList}
      </ul>
    </div>
  );
}
---------------------- 

function ListItem(props) {
  return <li>{props.animal}</li>
}
function List(props) {
  return (
    <ul>
      {props.animals.map((animal) => {
        return animal.startsWith("L") ? <ListItem key={animal} animal={animal} /> : null;
        // we return null to indicate that no element will be rendered.
  //         return animal.startsWith("L") && <li key={animal}>{animal}</li>;
This also works - if the first clause/condition is true then the second clause after && runs. if not, it's false
When using && for conditional rendering, 
* don’t put numbers on the left side. * 
The React docs on conditional rendering provide more details about this in the Pitfall box in the section about &&.
      })}
    </ul>
  );
}
---------------

function App() {
  const animals = ["Lion", "Cow", "Snake", "Lizard"];
  return (
    <div>
      <h1>Animals: </h1>
      <List animals={animals} />
    </div>
  );
}
function List(props) {
  if (!props.animals) {
    return <div>Loading...</div>;
  }
  if (props.animals.length === 0) {
    return <div>There are no animals in the list!</div>;
  }
  return (
    <ul>
      {props.animals.map((animal) => {
        return <li key={animal}>{animal}</li>;
      })}
    </ul>
  );
}
function App() {
  const animals = [];
  return (
    <div>
      <h1>Animals: </h1>
      <List animals={animals} />
    </div>
  );
}

-------------

function List(props) {
  return (
    <>
      {!props.animals ? (
        <div>Loading...</div>
      ) : props.animals.length > 0 ? (
        <ul>
          {props.animals.map((animal) => {
            return <li key={animal}>{animal}</li>;
          })}
        </ul>
      ) : (
        <div>There are no animals in the list!</div>
      )}
    </>
  );
}
// OR
function List(props) {
  return (
    <>
      {!props.animals && <div>Loading...</div>}
      {props.animals && props.animals.length > 0 && (
        <ul>
          {props.animals.map((animal) => {
            return <li key={animal}>{animal}</li>;
          })}
        </ul>
      )}
      {props.animals && props.animals.length === 0 && <div>There are no animals in the list!</div>}
    </>
  );
}
function App() {
  const animals = [];
  return (
    <div>
      <h1>Animals: </h1>
      <List animals={animals} />
    </div>
  );
} 
 ## CONDITIONAL RENDERING ##
 In React, control flow (like conditions) is handled by JavaScript.
function Item({ name, isPacked }) {
  if (isPacked) {
    return <li className="item">{name} ✅</li>; // if the item in the list has true for their isPacked property, they get a checkmark
  }
  return <li className="item">{name}</li>;
}

export default function PackingList() {
  return (
    <section>
      <h1>Sally Ride's Packing List</h1>
      <ul>
        <Item 
          isPacked={true} 
          name="Space suit" 
        />
        <Item 
          isPacked={true} 
          name="Helmet with a golden leaf" 
        />
        <Item 
          isPacked={false} 
          name="Photo of Tam" 
        />
      </ul>
    </section>
  );
}

A simpler solution:
if (isPacked) {
  return null; // therefore the items don't show up on the webpage
}
return <li className="item">{name}</li>;
But take note: In practice, returning null from a component isn’t common because it might surprise a developer trying to render it. More often, you would conditionally include or exclude the component in the parent component’s JSX. 

Use conditional rendering to stay D.R.Y. compliant:
return (
  <li className="item">
    {isPacked ? name + ' ✅' : name}
  </li>
);

Another option: the logical &&
return (
  <li className="item">
    {name} {isPacked && '✅'}
  </li>
);
You can read this as “if isPacked, then (&&) render the checkmark, otherwise, render nothing”.
DO NOT USE NUMBER WITH THE LOGICAL &&
For example, a common mistake is to write code like 
messageCount && <p>New messages</p>. 
It’s easy to assume that it renders nothing when messageCount is 0, but it really renders the 0 itself!

To fix it, make the left side a boolean: messageCount > 0 && <p>New messages</p>.

Example: 
function Item({ name, importance }) {
  return (
    <li className="item">
      { name } // notice there are multiple JSX brackets; this is HTML and the JSX is dynamically rendered
{/*       { importance > 0 ? <i> Importance: {importance} </i> : ''} */}
      { importance > 0 && ' '}
      { importance > 0 && <i> Importance: {importance} </i> }
    </li>
  );
}

export default function PackingList() {
  return (
    <section>
      <h1>Sally Ride's Packing List</h1>
      <ul>
        <Item 
          importance={9} 
          name="Space suit" 
        />
        <Item 
          importance={0} 
          name="Helmet with a golden leaf" 
        />
        <Item 
          importance={6} 
          name="Photo of Tam" 
        />
      </ul>
    </section>
  );
}

---------------------------- 
Option 1:
function Drink({ name }) {
  let part, caffeine, age;
  if (name === 'tea') {
    part = 'leaf';
    caffeine = '15–70 mg/cup';
    age = '4,000+ years';
  } else if (name === 'coffee') {
    part = 'bean';
    caffeine = '80–185 mg/cup';
    age = '1,000+ years';
  }
  return (
    <section>
      <h1>{name}</h1>
      <dl>
        <dt>Part of plant</dt>
        <dd>{part}</dd>
        <dt>Caffeine content</dt>
        <dd>{caffeine}</dd>
        <dt>Age</dt>
        <dd>{age}</dd>
      </dl>
    </section>
  );
}

export default function DrinkList() {
  return (
    <div>
      <Drink name="tea" />
      <Drink name="coffee" />
    </div>
  );
}

Option 2:
const drinks = {
  tea: {
    part: 'leaf',
    caffeine: '15–70 mg/cup',
    age: '4,000+ years'
  },
  coffee: {
    part: 'bean',
    caffeine: '80–185 mg/cup',
    age: '1,000+ years'
  }
};

function Drink({ name }) {
  const info = drinks[name];
  return (
    <section>
      <h1>{name}</h1>
      <dl>
        <dt>Part of plant</dt>
        <dd>{info.part}</dd>
        <dt>Caffeine content</dt>
        <dd>{info.caffeine}</dd>
        <dt>Age</dt>
        <dd>{info.age}</dd>
      </dl>
    </section>
  );
}

export default function DrinkList() {
  return (
    <div>
      <Drink name="tea" />
      <Drink name="coffee" />
    </div>
  );
}

### Rendering Lists ###
Here’s a short example of how to generate a list of items from an array:

Move the data into an array:
const people = [
  'Creola Katherine Johnson: mathematician',
  'Mario José Molina-Pasquel Henríquez: chemist',
  'Mohammad Abdus Salam: physicist',
  'Percy Lavon Julian: chemist',
  'Subrahmanyan Chandrasekhar: astrophysicist'
];
Map the people members into a new array of JSX nodes, listItems:
const listItems = people.map(person => <li>{person}</li>);
Return listItems from your component wrapped in a <ul>:
return <ul>{listItems}</ul>;



### KEYS ###
Keys are special props for components. Props are arguments passed into react components. 
*Props are reactive!*
Now imagine, if any of the items in the list on the DOM were to change, how would React know which item to update?
If the list were to change, one of two things should happen:
- we completely re-render the entire list, or
- we hunt down the specific items that were changed and only re-render those. (we assume this because it's not as costly in memory - therefore we need keys). Whenever a list is updated React matches the keys of each of the previous list items to the updated list. If there are changes, React only updates the items that have changed. 
<Component key={keyValue} />
//or
<div key={keyValue} />

// a list of todos, each todo object has a task and an id
const todos = [
  { task: "mow the yard", id: crypto.randomUUID() },
  { task: "Work on Odin Projects", id: crypto.randomUUID() },
  { task: "feed the cat", id: crypto.randomUUID() }, 
];
function TodoList() {
  return (
    <ul>
      {todos.map((todo) => (
        // here we are using the already generated id as the key.
        // do not write crypto.randomUUID() for the key during render
        <li key={todo.id}>{todo.task}</li>
      ))}
    </ul>
  );
}

Keys should NEVER be generated on the fly. Using key={Math.random()} or key={crypto.randomUUID()} *while* rendering the list defeats the purpose of the key, as now a new key will get created for every render of the list. Keys should always be inferred from the data directly. 

***You need to give each array item a key — a string or a number that uniquely identifies it among other items in that array: ***
<li key={person.id}>...</li>
JSX elements directly inside a map() call always need keys!
Keys tell React which array item each component corresponds to, so that it can match them up later. This becomes important if your array items can move (e.g. due to sorting), get inserted, or get deleted. A well-chosen key helps React infer what exactly has happened, and make the correct updates to the DOM tree. You should generate the keys directly in your data:
export const people = [{
  id: 0,         // Used in JSX as a key
  name: 'Creola Katherine Johnson',
  profession: 'mathematician',
  accomplishment: 'spaceflight calculations',
  imageId: 'MK3eW3A'
}...]

* What do you do when each item needs to render not one, but several DOM nodes? *
The short <>...</> Fragment syntax won’t let you pass a key, so you need to either group them into a single <div>, or use the slightly longer and more explicit <Fragment> syntax:

import { Fragment } from 'react';
// ...
const listItems = people.map(person =>
  <Fragment key={person.id}>
    <h1>{person.name}</h1>
    <p>{person.bio}</p>
  </Fragment>
);
Fragments disappear from the DOM, so this will produce a flat list of <h1>, <p>, <h1>, <p>, and so on. 


Rules of keys:
Keys must be unique among siblings. However, it’s okay to use the same keys for JSX nodes in different arrays.
Keys must not change or that defeats their purpose! Don’t generate them while rendering.

You might be tempted to use an item’s index in the array as its key. In fact, that’s what React will use if you don’t specify a key at all. But the order in which you render items will change over time if an item is inserted, deleted, or if the array gets reordered. Index as a key often leads to subtle and confusing bugs.
Note that your components won’t receive key as a prop. It’s only used as a hint by React itself. If your component needs an ID, you have to pass it as a separate prop: 
<Profile key={id} userId={id} />.

Example: 
import { recipes } from './data.js';
function Recipe({ id, name, ingredients }) {
  return (
    <div>
      <h2>{name}</h2>
      <ul>
        {ingredients.map(ingredient =>
          <li key={ingredient}>
            {ingredient}
          </li>
        )}
      </ul>
    </div>
  );
}
export default function RecipeList() {
  return (
    <div>
      <h1>Recipes</h1>
      {recipes.map(recipe =>
        <Recipe {...recipe} key={recipe.id} />
      )}
    </div>
  );
}
^^^^^
Here, <Recipe {...recipe} key={recipe.id} /> is a syntax shortcut saying “pass all properties of the recipe object as props to the Recipe component”. You could also write each prop explicitly: <Recipe id={recipe.id} name={recipe.name} ingredients={recipe.ingredients} key={recipe.id} />.

Note that the key is specified on the <Recipe> itself rather than on the root <div> returned from Recipe. This is because this key is needed directly within the context of the surrounding array. Previously, you had an array of <div>s so each of them needed a key, but now you have an array of <Recipe>s. In other words, when you extract a component, don’t forget to leave the key outside the JSX you copy and paste.

import { Fragment } from 'react';

const poem = {
  lines: [
    'I write, erase, rewrite',
    'Erase again, and then',
    'A poppy blooms.'
  ]
};

export default function Poem() {
  return (
    <article>
      {poem.lines.map((line, i) =>
        <Fragment key={i}>
          {i > 0 && <hr />} // the objective was to insert a hr in-between lines of the poem
          <p>{line}</p>
        </Fragment>
      )}
    </article>
  );
}

React lets you override the default behavior, and force a component to reset its state by passing it a different key, like <Chat key={email} />
So if the email of the recipient changes, so does the component via resetting. 

### PASSING DATA WITH PROPS ###
How can I share information between components? - Enter PROPS (React properties)

Props are reactive!!

If the color prop changes, React automatically re-renders the component with the new props.color value.
There's no need for state (useState) in some cases because the color is derived directly from the props.

React components use props to communicate with each other. Every parent component can pass some information to its child components by giving them props. 
Props might remind you of HTML attributes, but you can pass any JavaScript value through them, including objects, arrays, and functions.
In React, data is transferred from parent components to child components via props. The flow is UNIDIRECTIONAL - meaning it only flows in one direction. 
THEREFORE any changes made to this data will only affect child components using the data, and not parent or sibling components.
React component functions accept a single argument, a props object. You can think of props like “knobs” that you can adjust. 

Props are the information that you pass to a JSX tag. The props you can pass to an <img> tag are predefined (ReactDOM conforms to the HTML standard). 
But you can pass ANY props to your own components, such as <Avatar>, to customize them. Usually you don’t need the whole props object itself, so you destructure it into individual props.

export default function Profile() {
  return (
    <Avatar
      person={{ name: 'Lin Lanying', imageId: '1bX5QH6' }} // an object inside of JSX
      size={100}
    />
  );
}
function Avatar({ person, size }) { // props go here in this form - don't forget the curly braces
  // person and size are available here
}

function Avatar({ person, size = 100 }) { // default props
  // ...
} 
and this are equal: 
function Avatar(props) {
  let person = props.person;
  let size = props.size;
  // ...
}

function Profile(props) {
  return (
    <div className="card">
      <Avatar {...props} />
    </div>
  );
}
This forwards all of Profile’s props to the Avatar without listing each of their names.

When you nest content inside a JSX tag, the parent component will receive that content in a prop called children. 
For example, the Card component below will receive a children prop set to <Avatar /> and render it in a wrapper div:
import Avatar from './Avatar.js';
function Card({ children }) {
  return (
    <div className="card">
      {children}
    </div>
  );
}
export default function Profile() {
  return (
    <Card>
      <Avatar
        size={100}
        person={{ 
          name: 'Katsuko Saruhashi',
          imageId: 'YfeOqp2'
        }}
      />
    </Card>
  );
}

function Button(props) { // The Button functional component now receives props as a function argument.
  // if we need to have mutltiple buttons, having props can help us not repeat ourselves or make multiple components
  const buttonStyle = {
    color: props.color, // props.propertyName for the reference
    fontSize: props.fontSize + 'px'
  };

  return (
    <button style={buttonStyle}>{props.text}</button>  // the prop values are defined on each component while rendering
  );
}
export default function App() {
  return (
    <div>
      <Button text="Click Me!" color="blue" fontSize={12} />
      <Button text="Don't Click Me!" color="red" fontSize={12} />
      <Button text="Click Me!" color="blue" fontSize={20} />
    </div>
  );
}

function Button({ text, color, fontSize }) { // DESTRUCTURING WITHIN THE SAME EXAMPLE _ VERY COMMON
  const buttonStyle = {
    color: color,
    fontSize: fontSize + "px"
  };
  return <button style={buttonStyle}>{text}</button>;
}
export default function App() {
  return (
    <div>
      <Button text="Click Me!" color="blue" fontSize={12} />
      <Button text="Don't Click Me!" color="red" fontSize={12} />
      <Button text="Click Me!" color="blue" fontSize={20} />
    </div>
  );
}
Props are like properties incuded in the Button component in the JSX element itself. 

* Default Props *
  function Button({ text = "Click Me!", color = "blue", fontSize = 12 }) { // default props also a possibility
     const buttonStyle = {
      color: color,
      fontSize: fontSize + "px"
    };

    return <button style={buttonStyle}>{text}</button>;
  }
  export default function App() {
    return (
      <div>
        <Button />
        <Button text="Don't Click Me!" color="red" />
        <Button fontSize={20} />
      </div>
    );
  }
Now we only need to supply prop values to Button when rendering within App if they differ from the default values defined in the function parameters.
There also used to be a set word called defaultProps:

function Button({ text, color, fontSize }) {
  const buttonStyle = {
    color: color,
    fontSize: fontSize + "px"
  };
  return <button style={buttonStyle}>{text}</button>;
}
Button.defaultProps = { // you might see this in older codebases
  text: "Click Me!",
  color: "blue",
  fontSize: 12
};
export default function App() {
  return (
    <div>
      <Button />
      <Button text="Don't Click Me!" color="red" />
      <Button fontSize={20} />
    </div>
  );
}

WE CAN ALSO PASS FUNCTIONS AS PROPS: 
function Button({ text = "Click Me!", color = "blue", fontSize = 12, handleClick }) {
  const buttonStyle = {
    color: color,
    fontSize: fontSize + "px"
  };
  return (
    <button onClick={handleClick} style={buttonStyle}>
      {text}
    </button>
  );
}
export default function App() {
  const handleButtonClick = () => {
    window.location.href = "https://www.google.com";
  };
  return (
    <div>
      <Button handleClick={handleButtonClick} />
    </div>
  );
}
- We only pass through a reference to handleButtonClick, i.e. we do not include parenthesis when passing the function to Button. If we were to do something like handleClick={handleButtonClick()} then the function would be called as the button renders.

- Every Button calling this function will navigate to the same page. We can refactor the function and supply an argument within the Button to customize this functionality.

function Button({ text = "Click Me!", color = "blue", fontSize = 12, handleClick }) {
  const buttonStyle = {
    color: color,
    fontSize: fontSize + "px"
  };
  return (
    <button onClick={handleClick} style={buttonStyle}>
      {text}
    </button>
  );
}
export default function App() {
  const handleButtonClick = (url) => { // this version has a property that changes the destination of the click
    window.location.href = url;
  };
  return (
    <div>
      <Button handleClick={() => handleButtonClick('www.theodinproject.com')} /> 
    </div>
  );
}
When supplying an argument to the function we can’t just write onClick={handleClick('www.theodinproject.com')}, and instead must attach a reference to an anonymous function which then calls the function with the argument.

*** Props can change over time ***
export default function Clock({ color, time }) {
  return (
    <h1 style={{ color: color }}>
      {time}
    </h1>
  );
}
A component may receive different props over time. Props are not always static! Here, the time prop changes every second, 
and the color prop changes when you select another color. Props reflect a component’s data at any point in time, rather 
than only in the beginning.

However, props are immutable — a term from computer science meaning “unchangeable”. When a component needs to change its props 
(for example, in response to a user interaction or new data), it will have to “ask” its parent component to pass it different props
— a new object! Its old props will then be cast aside, and eventually the JavaScript engine will reclaim the memory taken by them.

Don’t try to “change props”. Props are read-only snapshots in time: every render receives a new version of props. When you need to 
respond to the user input (like changing the selected color), you will need to “set state”. 

# STATE IN REACT #
What is state? No matter if you work in web development, frontend or backend, with JavaScript, with a framework like React, Angular or Vue or without one - you will be working with state!
The state is the combination of all the data we currently have in our appliication. Component-specific memory is called state.

"State" is really just that: The state (i.e. "current snapshot") of your program or of a part of it - depending on how you look at it.
A component needs to “remember” things about itself. This is where state comes in. State is a component’s memory.
You can have as many state variables of as many types as you like in one component.
export default function Gallery() {
  const [index, setIndex] = useState(0);
  const [showMore, setShowMore] = useState(false);
  ... }

EXAMPLE:
import React, { useState } from "react";
import "./App.css";
const COLORS = ["pink", "green", "blue", "yellow", "purple"];

function App() {
  const [backgroundColor, setBackgroundColor] = useState(COLORS[0]); // the only argument for useState is the initial value of your variable
  const onButtonClick = (color) => () => {
    setBackgroundColor(color);
  };
  return (
    <div
      className="App"
      style={{
        backgroundColor,
      }}
    >
      {COLORS.map((color) => (
        <button
          type="button"
          key={color}
          onClick={onButtonClick(color)}
          className={backgroundColor === color ? "selected" : ""}
        >
          {color}
        </button>
      ))}
    </div>
  );
}

To update a component with new data, two things need to happen:
- Retain the data between renders.
- Trigger React to render the component with new data (re-rendering). -- ANKI

The useState hook is a built-in hook in React that allows you to define state in a functional component. 
It takes an initial value as a parameter and returns an array with two elements that we can destructure to get:
- The current state value
- A function to update the state variable and trigger React to render the component again
The array returned by useState always has exactly two items.

const [stateValue, setStateValue] = useState(initialValue);
// adapted for our use case:
const [backgroundColor, setBackgroundColor] = useState(initialColor);

** How does state work under the hood? **
* In React, when a component’s state or props change, the component is destroyed and recreated from scratch. 
The entire component is recreated but this time the latest state value will be returned from useState. 
This process is called rerendering. Rerendering is a key feature of React that enables it to efficiently 
update the user interface in response to changes in the underlying data.

* STATE IS ISOLATED AND PRIVATE *
If you render the same component twice, each copy will have completely isolated state! 

It is a good idea to have multiple state variables in a single component if their state is unrelated, like index and showMore in this example. 
But if you find that you often change two state variables together, it might be easier to combine them into one. For example, 
if you have a form with many fields, it’s more convenient to have a single state variable that holds an object than state 
variable per field. 

Unlike props, state is FULLY PRIVATE to the component declaring it. The parent component can’t change it. This lets you add state 
to any component or remove it without impacting the rest of the components.

What if you wanted two components to keep their states in sync? The right way to do it in React is to remove state from 
child components and add it to their closest shared parent.

import {useState} from 'react';
export default function Form() {
  // let firstName = '';
  // let lastName = '';
  const [firstName, setFirstName] = useState('');
  const [lastName, setLastName] = useState('');

  function handleFirstNameChange(e) {
    // firstName = e.target.value;
    setFirstName(e.target.value)
  }
  function handleLastNameChange(e) {
    // lastName = e.target.value;
    setLastName(e.target.value); 
  }
  function handleReset() {
    firstName = '';
    lastName = '';
  }
  return (
    <form onSubmit={e => e.preventDefault()}>
      <input
        placeholder="First name"
        value={firstName}
        onChange={handleFirstNameChange}
      />
      <input
        placeholder="Last name"
        value={lastName}
        onChange={handleLastNameChange}
      />
      <h1>Hi, {firstName} {lastName}</h1>
      <button onClick={handleReset}>Reset</button>
    </form>
  );
}

A state variable is only necessary to keep information between re-renders of a component. Within a single event handler, 
a regular variable will do fine. Don’t introduce state variables when a regular variable works well.

Imagine that your components are cooks in a kitchen that serve UI, React is the waiter. The process of requesting and serving 
UI has three steps:
- Triggering a render (delivering the guest’s order to the kitchen):
There are two reasons for a component to render:
1. It’s the component’s initial render.
import Image from './Image.js';
import { createRoot } from 'react-dom/client';
const root = createRoot(document.getElementById('root'))
root.render(<Image />);
2. The component’s (or one of its ancestors’) state has been updated.

- Rendering the component (preparing the order in the kitchen)
1. “Rendering” is React calling your components.
2. On initial render, React will call the root component.
3. For subsequent renders, React will call the function component whose state update triggered the render.

* Rendering must always be a pure calculation:
- ** Same inputs, same output: ** Given the same inputs, a component should always return the same JSX. 
(When someone orders a salad with tomatoes, they should not receive a salad with onions!)
- ** It minds its own business: ** It should not change any objects or variables that existed before rendering. 
(One order should not change anyone else’s order.)
Otherwise, you can encounter confusing bugs and unpredictable behavior as your codebase grows in complexity. 
When developing in “Strict Mode”, React calls each component’s function twice, which can help surface mistakes 
caused by impure functions.
-  Committing to the DOM (placing the order on the table)
1. For the initial render, React will use the appendChild() DOM API to put all the DOM nodes it has created on screen.
2. For re-renders, React will apply the minimal necessary operations (calculated while rendering!) to make the DOM match 
the latest rendering output.
React only changes the DOM nodes if there’s a difference between renders. For example, here is a component that 
re-renders with different props passed from its parent every second. 

* Setting State does not change the state variable you already have, but instead triggers a re-render. Setting state triggers re-renders. Setting state only changes state for the NEXT render.
- Rendering takes a snapshot of the UI in time. Its props, event handlers, and local variables were all calculated using its state at the time of the render. The UI snapshot is interactive. 

When React re-renders a component:
1. React calls your function again.
2. Your function returns a new JSX snapshot.
3. React then updates the screen to match the snapshot your function returned.

- A state variable’s value never changes within a render. 
- React keeps the state values “fixed” within one render’s event handlers.


## HOW TO STRUCTURE STATE ##
1. *Group related state*: If you always update two or more state variables at the same time, consider merging them into a single state variable.
const [x, setX] = useState(0);
const [y, setY] = useState(0);
OR 
* const [position, setPosition] = useState({ x: 0, y: 0 });
Grouping state is also helpful when you don't know how many state variables you need. 
* If your state variable is an object, remember that you CANNOT update only one field in it without explicitly copying the 
other fields. For example, you can’t do setPosition({ x: 100 }) in the above example because it would not have the y 
property at all! Instead, if you wanted to set x alone, you would either do setPosition({ ...position, x: 100 }), or 
split them into two state variables and do setX(100).

* But you shouldn’t change objects and arrays that you hold in the React state directly. Instead, when you want to 
update an object and array, you need to create a new one (or make a copy of an existing one), and then update the 
state to use that copy.

* Just like with objects, when you want to update an array stored in state, you need to create a new one (or make a 
copy of an existing one), and then set state to use the new array. If copying arrays in code gets tedious, you can 
use a library like Immer to reduce repetitive code. 


2. *Avoid contradictions in state*: When the state is structured in a way that several pieces of state may contradict and “disagree” with each other, you leave room for mistakes. Try to avoid this.
- Consider an example of a messaging app where state variables sent and sending are present and cannot both be true at the same time.
Since isSending and isSent should never be true at the same time, it is better to replace them with one status state variable that may take one of three valid states: 'typing' (initial), 'sending', and 'sent'. 

3. *Avoid redundant state*: If you can calculate some information from the component’s props or its existing state variables during rendering, you should not put that information into that component’s state.
* DO NOT put values in state that can be calculated using existing values, state, and/or props.
  const [firstName, setFirstName] = useState('');
  const [lastName, setLastName] = useState('');
  const [fullName, setFullName] = useState('');
  REDUNDANT

DO NOT copy props into state unless you want to ignore future updates to the prop. Instead, use the prop directly, or rename it with a constant for clarity. If you must copy it, name it with 'initial' or 'default' to signal that updates to the prop will be ignored.

4. *Avoid duplication in state*: When the same data is duplicated between multiple state variables, or within nested objects, it is difficult to keep them in sync. Reduce duplication when you can.
- We don't want to have information about state in multiple places; instead we can use that single source to calculate or populate the state where we need it

`import { useState } from 'react';
const initialItems = [
  { title: 'pretzels', id: 0 },
  { title: 'crispy seaweed', id: 1 },
  { title: 'granola bar', id: 2 },
];
export default function Menu() {
  const [items, setItems] = useState(initialItems);
  const [selectedId, setSelectedId] = useState(0);
  const selectedItem = items.find(item =>
    item.id === selectedId
  );

  function handleItemChange(id, e) {
    setItems(items.map(item => {
      if (item.id === id) {
        return {
          ...item,
          title: e.target.value,
        };
      } else {
        return item;
      }
    }));
  }
  return (
    <>
      <h2>What's your travel snack?</h2>
      <ul>
        {items.map((item, index) => (
          <li key={item.id}>
            <input
              value={item.title}
              onChange={e => {
                handleItemChange(item.id, e)
              }}
            />
            {' '}
            <button onClick={() => {
              setSelectedId(item.id);
            }}>Choose</button>
          </li>
        ))}
      </ul>
      <p>You picked {selectedItem.title}.</p>
    </>
  );
}


The state used to be duplicated like this:
  items = [{ id: 0, title: 'pretzels'}, ...]
  selectedItem = {id: 0, title: 'pretzels'}

But after the change it’s like this:
  items = [{ id: 0, title: 'pretzels'}, ...]
  selectedId = 0
The duplication is gone, and you only keep the essential state! You didn’t need to hold the selected item in state, because only the selected ID is essential. The rest could be calculated during render.

5. *Avoid deeply nested state*: Deeply hierarchical state is not very convenient to update. When possible, prefer to structure state in a flat way.
- Updating nested state involves making copies of objects all the way up from the part that changed. Deleting a deeply nested place would involve copying its entire parent place chain. Such code can be very verbose.
- If the state is too nested to update easily, consider making it “flat” or "normalized".

import { useState } from 'react';
import { initialTravelPlan } from './places.js';
export default function TravelPlan() {
  const [plan, setPlan] = useState(initialTravelPlan);
  function handleComplete(parentId, childId) {
    const parent = plan[parentId];
    // Create a new version of the parent place
    // that doesn't include this child ID.
    const nextParent = {
      ...parent,
      childIds: parent.childIds
        .filter(id => id !== childId)
    };
    // Update the root state object...
    setPlan({
      ...plan,
      // ...so that it has the updated parent.
      [parentId]: nextParent
    });
  }
  const root = plan[0];
  const planetIds = root.childIds;
  return (
    <>
      <h2>Places to visit</h2>
      <ol>
        {planetIds.map(id => (
          <PlaceTree
            key={id}
            id={id}
            parentId={0}
            placesById={plan}
            onComplete={handleComplete}
          />
        ))}
      </ol>
    </>
  );
}
function PlaceTree({ id, parentId, placesById, onComplete }) {
  const place = placesById[id];
  const childIds = place.childIds;
  return (
    <li>
      {place.title}
      <button onClick={() => {
        onComplete(parentId, id);
      }}>
        Complete
      </button>
      {childIds.length > 0 &&
        <ol>
          {childIds.map(childId => (
            <PlaceTree
              key={childId}
              id={childId}
              parentId={id}
              placesById={placesById}
              onComplete={onComplete}
            />
          ))}
        </ol>
      }
    </li>
  );
}

* Rule #2: State should NOT be mutated
  - Mutating state is a no-go area in React as it leads to unpredictable results.
  - We should treat state as if it was immutable. To change state, we should always use the setState function, 
  which in the case of the example below is the setPerson function.

    // BAD - Don't do this!
  const handleIncreaseAge = () => {
    // mutating the current state object
    person.age = person.age + 1;
    setPerson(person);
  };

  // GOOD - Do this!
  const handleIncreaseAge = () => {
    // copy the existing person object into a new object
    // while updating the age property
    const newPerson = { ...person, age: person.age + 1 };
    setPerson(newPerson);
  };
- If we don’t provide a new object to setState it is not guaranteed to re-render the page. Therefore, we should always 
provide a new Object for setState to trigger a re-render. 

* State updates are ASYNCHRONOUS
 - What this implies is that whenever you call the setState function, React will apply the update in the *NEXT* component render.
 - state variables are NOT reactive - the component is

 The state stays the same throughout the current render of the component. This is what “state as a snapshot” refers to. 
 The setState call triggers a component re-render, and the person state is updated to the new value.

 function Component() { // this is an infinite loop - eachh setCount rerenders the component thus calling setCount again
  const [count, setCount] = useState(0);
  setCount(count + 1);
  return <h1>{count}</h1>;
}

### State updater functions ###
const handleIncreaseAge = () => { // this does NOT update state twice!!!
  setPerson({ ...person, age: person.age + 1 });
  setPerson({ ...person, age: person.age + 1 });
}; - this performs the same action twice but it doesn't rerender so it essentially => 100 + 1 and then 100 + 1 again

1. The component renders for the first time. The person state variable is initialized to { name: 'John', age: 100 }. The “during render” console.log prints the state variable.
2. The button is clicked invoking handleIncreaseAge. Interestingly, the console.log before and after the setPerson call prints the same value.
3. The component re-renders. The person state variable is updated to { name: 'John', age: 101 }.

What if I want to update the state multiple times using the latest state?
const handleIncreaseAge = () => { // passing in the previous person to update the latest state twice
  setPerson((prevPerson) => ({ ...prevPerson, age: prevPerson.age + 1 }));
  setPerson((prevPerson) => ({ ...prevPerson, age: prevPerson.age + 1 }));
};

* Because there are two setState calls, you would think React re-renders the component twice, right? 
NOPE! Wherever possible, React *batches the state updates*. Here, the component only re-renders once. 

### State Reducer Function - useReducer ### // DID NOT MAKE FLASHCARD FOR THIS
Components with many state updates spread across many event handlers can get overwhelming. For these cases, 
you can consolidate all the state update logic outside your component in a single function, called “reducer”. 
Your event handlers become concise because they only specify the user “actions”. 

import { useReducer } from 'react';
import AddTask from './AddTask.js';
import TaskList from './TaskList.js';
export default function TaskApp() {
  const [tasks, dispatch] = useReducer(
    tasksReducer,
    initialTasks
  );
  function handleAddTask(text) {
    dispatch({
      type: 'added',
      id: nextId++,
      text: text,
    });
  }
  function handleChangeTask(task) {
    dispatch({
      type: 'changed',
      task: task
    });
  }
  function handleDeleteTask(taskId) {
    dispatch({
      type: 'deleted',
      id: taskId
    });
  }

  return (
    <>
      <h1>Prague itinerary</h1>
      <AddTask
        onAddTask={handleAddTask}
      />
      <TaskList
        tasks={tasks}
        onChangeTask={handleChangeTask}
        onDeleteTask={handleDeleteTask}
      />
    </>
  );
}
function tasksReducer(tasks, action) {
  switch (action.type) {
    case 'added': {
      return [...tasks, {
        id: action.id,
        text: action.text,
        done: false
      }];
    }
    case 'changed': {
      return tasks.map(t => {
        if (t.id === action.task.id) {
          return action.task;
        } else {
          return t;
        }
      });
    }
    case 'deleted': {
      return tasks.filter(t => t.id !== action.id);
    }
    default: {
      throw Error('Unknown action: ' + action.type);
    }
  }
}
let nextId = 3;
const initialTasks = [
  { id: 0, text: 'Visit Kafka Museum', done: true },
  { id: 1, text: 'Watch a puppet show', done: false },
  { id: 2, text: 'Lennon Wall pic', done: false }
];

### useContext ### // DID NOT MAKE FLASHCARD FOR THIS

import React, { createContext, useContext } from "react";
// Create a Context for the level
const LevelContext = createContext(1); // acts as a shared information hub or intranet for all components that need level

export default function App() {
  return (
    <Section>
      <Heading /> 
      <Section>
        <Heading />
        <Section>
          <Heading />
        </Section>
      </Section>
    </Section>
  );
}
function Section({ children }) {
  // Get the current level from context
  const level = useContext(LevelContext); // Each Heading and Section uses useContext(LevelContext) to get the current level.

  return (
    <LevelContext.Provider value={level + 1}>  // Each Section increments the level it receives by 1 and provides it to its children using the LevelContext.Provider.
      <div style={{ marginLeft: "20px", border: "1px solid black", padding: "10px" }}>
        <p>Section Level: {level}</p>
        {children}
      </div>
    </LevelContext.Provider>
  );
}
function Heading() {
  // Get the current level from context
  const level = useContext(LevelContext); // Each Heading and Section uses useContext(LevelContext) to get the current level.

  // Dynamically render the heading tag
  const Tag = `h${level}`;
  return <Tag>This is an h{level} heading</Tag>;
}

Why Context is Powerful:
- Removes the need for prop drilling.
- Makes the code cleaner and easier to maintain.
- Lets you share global data (like themes, user info, etc.) across deeply nested components seamlessly.


### Controlled Components ###
Some native HTML elements control their own state - like inputs, but we want to control our own inputs for now. 

function CustomInput() {
  const [value, setValue] = useState("");
  return (
    <input
      type="text"
      value={value}
      onChange={(event) => setValue(event.target.value)}
    />
  );
}
Now, every time the user types something in the input, React will ensure you have the latest comment, review, 
or post (whatever the user was typing) in value.

## SHARING STATE BETWEEN COMPONENTS ##
Remove state from both of them, move it to their closest common parent, and then pass it down to them via props. 
This is known as *lifting state up*, and it’s one of the most common things you will do writing React code.

To coordinate two states of two different components together, you need to “lift their state up” to a parent component in three steps:
1. Remove state from the child components.
- First give control of the components state to the common parent component. Instead, add it as a list of props the components 
inherits and the common parent has control of the state. 
2. Pass hardcoded data from the common parent.
3. Add state to the common parent and pass it down together with the event handlers.
- Lifting state up often changes the nature of what you’re storing as state. For example, when state is in the component, 
it might need to store a value as a boolean, but in the parent ciomponent it might need to be an index/number. 

The parent component needs to explicitly allow the child component to change its state by passing an event handler down as a prop:
<>
  <Panel
    isActive={activeIndex === 0}
    onShow={() => setActiveIndex(0)}
  >
    ...
  </Panel>
  <Panel
    isActive={activeIndex === 1}
    onShow={() => setActiveIndex(1)}
  >
    ...
  </Panel>
</>

import { useState } from 'react';

export default function Accordion() {
  const [activeIndex, setActiveIndex] = useState(0);
  return (
    <>
      <h2>Almaty, Kazakhstan</h2>
      <Panel
        title="About"
        isActive={activeIndex === 0}
        onShow={() => setActiveIndex(0)}
      >
        With a population of about 2 million, Almaty is Kazakhstan's largest city. From 1929 to 1997, it was its capital city.
      </Panel>
      <Panel
        title="Etymology"
        isActive={activeIndex === 1}
        onShow={() => setActiveIndex(1)}
      >
        The name comes from <span lang="kk-KZ">алма</span>, the Kazakh word for "apple" and is often translated as "full of apples". In fact, the region surrounding Almaty is thought to be the ancestral home of the apple, and the wild <i lang="la">Malus sieversii</i> is considered a likely candidate for the ancestor of the modern domestic apple.
      </Panel>
    </>
  );
}

function Panel({
  title,
  children,
  isActive,
  onShow
}) {
  return (
    <section className="panel">
      <h3>{title}</h3>
      {isActive ? (
        <p>{children}</p>
      ) : (
        <button onClick={onShow}>
          Show
        </button>
      )}
    </section>
  );
}

For each unique piece of state, you will choose the component that “owns” it. This principle is also known as having a “single source of truth”. It doesn’t mean that all state lives in one place—but that for each piece of state, there is a specific component that holds that piece of information. 

Your app will change as you work on it. It is common that you will move state down or back up while you’re still figuring out where each piece of the state “lives”. This is all part of the process!

# HOOKS #
Hooks are functions that let you use React features. All hooks are recognizable by the "use" prefix. 
Hooks are special functions that are only available while React is rendering. They let you “hook into” different React features.
For example, useState is a hook. For now, remember that hooks have rules that we need to abide by:
- Hooks can only be called from the top level of a functional component.
- Hooks can’t be called from inside loops or conditions. 
It is very IMPORTANT that all calls to Hooks happen BEFORE the first return statement.

Hooks—functions starting with use—can only be called at the top level of your components or your own Hooks. You can’t call Hooks 
inside conditions, loops, or other nested functions. Hooks are functions, but it’s helpful to think of them as unconditional 
declarations about your component’s needs. You “use” React features at the top of your component similar to how you “import” 
modules at the top of your file.

import { useState } from 'react';
import { sculptureList } from './data.js';

export default function Gallery() {
  const [index, setIndex] = useState(0);
  const [showMore, setShowMore] = useState(false);
  function handleNextClick() {
    setIndex(index + 1);
  }
  function handleMoreClick() {
    setShowMore(!showMore);
  }
  let sculpture = sculptureList[index];
  return (
    <>
      <button onClick={handleNextClick}>
        Next
      </button>
      <h2>
        <i>{sculpture.name} </i> 
        by {sculpture.artist}
      </h2>
      <h3>  
        ({index + 1} of {sculptureList.length})
      </h3>
      <button onClick={handleMoreClick}>
        {showMore ? 'Hide' : 'Show'} details
      </button>
      {showMore && <p>{sculpture.description}</p>}
      <img 
        src={sculpture.url} 
        alt={sculpture.alt}
      />
    </>
  );
}
-- ANKI

# useEffect #
Sometimes components in React need to interact with things outside themselves. This interaction with the outside world is called a SIDE-EFFECT.
Effects let you run some code to synchronize your component as necessary, on rendering or a reactive/state value change rather than on a particular event. 
useEffect is a mechanism outside the concepts that React usually applies, allowing you to sync your component with various external systems like a server, API, or browser DOM. The single question that you can ask yourself before you use an effect is if there are any such external systems that need to be synced with, apart from props or state. Unnecessary useEffects are error prone and slow down performance. 

3 Parts for the useEffect Hook:
1. The Hook
2. The Dependency array

When we use useEffect we move it outside the rendering calculation. 

By default, useEffect hook runs on every render. the second argument accepts an array of dependencies allowing the hook to re-render only when those dependencies are changed.
We pass an empty array in this example because we do not want the useEffect hook to run anytime other than the initial component render.
Passing an empty array causes the useEffect hook to onnly run once because there is nothing in the dependency array. 
3. The Cleanup Function - You can return a function from the callback in the useEffect hook, which will be executed each time before the next effect is run, and one final time when the component is unmounted.

import { useEffect, useState } from "react";

export default function Clock() {
  const [counter, setCounter] = useState(0);
  useEffect(() => {
    const key = setInterval(() => {
      setCounter(count => count + 1)
    }, 1000);
    return () => {
      clearInterval(key);
    };
  }, [])
  return (
    <p>{counter} seconds have passed.</p>
  );
}


EXAMPLES: 
useEffect(() => {
  // This runs after every render
});

useEffect(() => {
  // This runs only on mount (when the component appears)
}, []);

useEffect(() => {
  // This runs on mount *and also* if either a or b have changed since the last render
}, [a, b]);

*** SUMMARY OF useEffect: ***
useEffect(
  () => {
    // execute side effect
    return () => {
      // cleanup function on unmounting or re-running effect
    }
  },
  // optional dependency array
  [/* 0 or more entries */]
)





