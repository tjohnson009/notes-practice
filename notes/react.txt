# Setting Up A React Environment #
There are many ways to start using React in your projects:
Some examples of these toolchains include:
- Vite’s React Config
- Gatsby
- NextJS
- Create React App (Deprecated): Create React App, or CRA, was the official way to scaffold new React projects since its introduction in 2016. Unfortunately, owing to many reasons, CRA was deprecated in early 2023. Due to CRA’s popularity, you’ll see it mentioned in many tutorials and guides. However, it’s no longer recommended to use it for new projects.
NOW we can start up react with a single terminal command
* VITE builds frontend tools for developers and it leverages the latest technologies under the hood to provide a great developer experience. Fortunately, it also caters to the React ecosystem. We will use Vite’s CLI to quickly create a template React project. 

*** npm create vite@latest my-react-app -- --template react ***
THEN: 
cd my-first-react-app
npm install
npm run dev 

If creating a react project in a existing repo:
*** npm create vite@latest . -- --template react ***
This will tell Vite to use the current directory for the project, instead of creating a new directory 
with the given project name. This cloned directory will already be initialized as a git repo and connected to the right remote.

# REACT COMPONENTS #
The beauty of React is that it allows you to break a UI (User Interface) down into independent reusable chunks, which we will refer to as components. Think of these reusable chunks as JavaScript functions which can take some kind of input and return a React element.

function Greeting() {
  return <h1>&quot;I swear by my pretty floral bonnet, I will end you.&quot;</h1>;
}
React components return JSX. 
* React components MUST be capitalized or they will not function as expected, which is why we capitalized Greeting().
*** For a very long time in React development, it was necessary to import React in your JavaScript files that used React components, but since React v17.0 it is no longer required. ***

# What is JSX? #
JSX is a syntax extension for JavaScript that lets you write HTML-like markup inside a JavaScript file. It’s NOT required to use JSX when writing React components, but it does make writing them more concise.
JSX is syntactic sugar for the React createElement function. JSX compiles down to plain JavaScript objects.
- Rules of JSX:
1. Return a sinlge root elementfunction App() {
  // Could replace <></> with <div></div>
  return (
    <> // this is called a React Fragment - single element
    Fragments let you group things without leaving any trace in the browser HTML tree.
      <h1>Example h1</h1>
      <h2>Example h2</h2>
    </>
  );
}
2. Close all tags
function App() {
  return (
    <>
      <input />
      <li></li>
    </>
  );
 }
3. camelCase most tags: JSX turns into JavaScript, and 
* attributes of elements become keys of JavaScript objects, *
so you can’t use dashes or reserved words such as class. Because of this, many HTML attributes are written in camelCase. Instead of stroke-width, you’d use strokeWidth, and instead of class you’d use className.

# JavaScript with Markup #
You can use curly braces in your JSX to open a window to JavaScript. That’s because curly braces let you work with JavaScript right there in your markup!
JSX is a special way of writing JavaScript. That means it’s possible to use JavaScript inside it—with curly braces { }. 
You can only use curly braces in two ways inside JSX:
1. As text directly inside a JSX tag: <h1>{name}'s To Do List</h1> works, but <{tag}>Gregorio Y. Zara's To Do List</{tag}> will not.
2. As attributes immediately following the = sign: src={avatar} will read the avatar variable, but src="{avatar}" will pass the string "{avatar}".

You can pass a JS object in JSX, but you must wrap the object in another pair of curly braces: 
person={{ name: "Hedy Lamarr", inventions: 5 }}.
You may see this with inline CSS styles in JSX. React does not require you to use inline styles (CSS classes work great for most cases). 
But when you need an inline style, you pass an object to the style attribute:
export default function TodoList() {
  return (
    <ul style={{ <--- SEE
      backgroundColor: 'black',
      color: 'pink'
    }}>
      <li>Improve the videophone</li>
      <li>Prepare aeronautics lectures</li>
      <li>Work on the alcohol-fuelled engine</li>
    </ul>
  );
}
The next time you see {{ and }} in JSX, know that it’s nothing more than an object inside the JSX curlies!
*** Inline style properties are written in camelCase. For example, HTML <ul style="background-color: black"> would be written as <ul style={{ backgroundColor: 'black' }}>  in your component. ***

CLEVER:
const person = {
  name: 'Gregorio Y. Zara',
  theme: {
    backgroundColor: 'black',
    color: 'pink'
  }
};

export default function TodoList() {
  return (
    <div style={person.theme}> // applies the styles from person.theme to the element

# Rendering and Conditional Rendering # 
function App() {
  const animals = ["Lion", "Cow", "Snake", "Lizard"];

  return (
    <div>
      <h1>Animals: </h1>
      <ul>
        {animals.map((animal) => { // this can take a list however logn we want and render it all as a list
          return <li key={animal}>{animal}</li>;
        })}
      </ul>
    </div>
  );
}
*** JSX has the ability to automatically render arrays, therefore these are the same *** 
function App() {
  const animals = ["Lion", "Cow", "Snake", "Lizard"];
  const animalsList = animals.map((animal) => <li key={animal}>{animal}</li>)

  return (
    <div>
      <h1>Animals: </h1>
      <ul>
        {animalsList}
      </ul>
    </div>
  );
}
----------------------

function ListItem(props) {
  return <li>{props.animal}</li>
}
function List(props) {
  return (
    <ul>
      {props.animals.map((animal) => {
        return animal.startsWith("L") ? <ListItem key={animal} animal={animal} /> : null;
        // we return null to indicate that no element will be rendered.
  //         return animal.startsWith("L") && <li key={animal}>{animal}</li>;
This also works - if the first clause/condition is true then the second clause after && runs. if not, it's false
When using && for conditional rendering, 
* don’t put numbers on the left side. * 
The React docs on conditional rendering provide more details about this in the Pitfall box in the section about &&.
      })}
    </ul>
  );
}
---------------

function App() {
  const animals = ["Lion", "Cow", "Snake", "Lizard"];
  return (
    <div>
      <h1>Animals: </h1>
      <List animals={animals} />
    </div>
  );
}
function List(props) {
  if (!props.animals) {
    return <div>Loading...</div>;
  }
  if (props.animals.length === 0) {
    return <div>There are no animals in the list!</div>;
  }
  return (
    <ul>
      {props.animals.map((animal) => {
        return <li key={animal}>{animal}</li>;
      })}
    </ul>
  );
}
function App() {
  const animals = [];
  return (
    <div>
      <h1>Animals: </h1>
      <List animals={animals} />
    </div>
  );
}

-------------

function List(props) {
  return (
    <>
      {!props.animals ? (
        <div>Loading...</div>
      ) : props.animals.length > 0 ? (
        <ul>
          {props.animals.map((animal) => {
            return <li key={animal}>{animal}</li>;
          })}
        </ul>
      ) : (
        <div>There are no animals in the list!</div>
      )}
    </>
  );
}
// OR
function List(props) {
  return (
    <>
      {!props.animals && <div>Loading...</div>}
      {props.animals && props.animals.length > 0 && (
        <ul>
          {props.animals.map((animal) => {
            return <li key={animal}>{animal}</li>;
          })}
        </ul>
      )}
      {props.animals && props.animals.length === 0 && <div>There are no animals in the list!</div>}
    </>
  );
}
function App() {
  const animals = [];
  return (
    <div>
      <h1>Animals: </h1>
      <List animals={animals} />
    </div>
  );
} 
 ## CONDITIONAL RENDERING ##
 In React, control flow (like conditions) is handled by JavaScript.
function Item({ name, isPacked }) {
  if (isPacked) {
    return <li className="item">{name} ✅</li>; // if the item in the list has true for their isPacked property, they get a checkmark
  }
  return <li className="item">{name}</li>;
}

export default function PackingList() {
  return (
    <section>
      <h1>Sally Ride's Packing List</h1>
      <ul>
        <Item 
          isPacked={true} 
          name="Space suit" 
        />
        <Item 
          isPacked={true} 
          name="Helmet with a golden leaf" 
        />
        <Item 
          isPacked={false} 
          name="Photo of Tam" 
        />
      </ul>
    </section>
  );
}

A simpler solution:
if (isPacked) {
  return null; // therefore the items don't show up on the webpage
}
return <li className="item">{name}</li>;
But take note: In practice, returning null from a component isn’t common because it might surprise a developer trying to render it. More often, you would conditionally include or exclude the component in the parent component’s JSX. 

Use conditional rendering to stay D.R.Y. compliant:
return (
  <li className="item">
    {isPacked ? name + ' ✅' : name}
  </li>
);

Another option: the logical &&
return (
  <li className="item">
    {name} {isPacked && '✅'}
  </li>
);
You can read this as “if isPacked, then (&&) render the checkmark, otherwise, render nothing”.
DO NOT USE NUMBER WITH THE LOGICAL &&
For example, a common mistake is to write code like 
messageCount && <p>New messages</p>. 
It’s easy to assume that it renders nothing when messageCount is 0, but it really renders the 0 itself!

To fix it, make the left side a boolean: messageCount > 0 && <p>New messages</p>.

Example: 
function Item({ name, importance }) {
  return (
    <li className="item">
      { name } // notice there are multiple JSX brackets; this is HTML and the JSX is dynamically rendered
{/*       { importance > 0 ? <i> Importance: {importance} </i> : ''} */}
      { importance > 0 && ' '}
      { importance > 0 && <i> Importance: {importance} </i> }
    </li>
  );
}

export default function PackingList() {
  return (
    <section>
      <h1>Sally Ride's Packing List</h1>
      <ul>
        <Item 
          importance={9} 
          name="Space suit" 
        />
        <Item 
          importance={0} 
          name="Helmet with a golden leaf" 
        />
        <Item 
          importance={6} 
          name="Photo of Tam" 
        />
      </ul>
    </section>
  );
}

---------------------------- 
Option 1:
function Drink({ name }) {
  let part, caffeine, age;
  if (name === 'tea') {
    part = 'leaf';
    caffeine = '15–70 mg/cup';
    age = '4,000+ years';
  } else if (name === 'coffee') {
    part = 'bean';
    caffeine = '80–185 mg/cup';
    age = '1,000+ years';
  }
  return (
    <section>
      <h1>{name}</h1>
      <dl>
        <dt>Part of plant</dt>
        <dd>{part}</dd>
        <dt>Caffeine content</dt>
        <dd>{caffeine}</dd>
        <dt>Age</dt>
        <dd>{age}</dd>
      </dl>
    </section>
  );
}

export default function DrinkList() {
  return (
    <div>
      <Drink name="tea" />
      <Drink name="coffee" />
    </div>
  );
}

Option 2:
const drinks = {
  tea: {
    part: 'leaf',
    caffeine: '15–70 mg/cup',
    age: '4,000+ years'
  },
  coffee: {
    part: 'bean',
    caffeine: '80–185 mg/cup',
    age: '1,000+ years'
  }
};

function Drink({ name }) {
  const info = drinks[name];
  return (
    <section>
      <h1>{name}</h1>
      <dl>
        <dt>Part of plant</dt>
        <dd>{info.part}</dd>
        <dt>Caffeine content</dt>
        <dd>{info.caffeine}</dd>
        <dt>Age</dt>
        <dd>{info.age}</dd>
      </dl>
    </section>
  );
}

export default function DrinkList() {
  return (
    <div>
      <Drink name="tea" />
      <Drink name="coffee" />
    </div>
  );
}

## Rendering Lists ##
Here’s a short example of how to generate a list of items from an array:

Move the data into an array:
const people = [
  'Creola Katherine Johnson: mathematician',
  'Mario José Molina-Pasquel Henríquez: chemist',
  'Mohammad Abdus Salam: physicist',
  'Percy Lavon Julian: chemist',
  'Subrahmanyan Chandrasekhar: astrophysicist'
];
Map the people members into a new array of JSX nodes, listItems:
const listItems = people.map(person => <li>{person}</li>);
Return listItems from your component wrapped in a <ul>:
return <ul>{listItems}</ul>;



### KEYS ###
Keys are special props for components. Props are arguments passed into react components. 
Now imagine, if any of the items in the list on the DOM were to change, how would React know which item to update?
If the list were to change, one of two things should happen:
- we completely re-render the entire list, or
- we hunt down the specific items that were changed and only re-render those. (we assume this because it's not as costly in memory - therefore we need keys). Whenever a list is updated React mataches the keys of each of the previous list items to the updated list. If there are changes, React only updates the items that have changed. 
<Component key={keyValue} />
//or
<div key={keyValue} />

// a list of todos, each todo object has a task and an id
const todos = [
  { task: "mow the yard", id: crypto.randomUUID() },
  { task: "Work on Odin Projects", id: crypto.randomUUID() },
  { task: "feed the cat", id: crypto.randomUUID() },
];
function TodoList() {
  return (
    <ul>
      {todos.map((todo) => (
        // here we are using the already generated id as the key.
        // do not write crypto.randomUUID() for the key during render
        <li key={todo.id}>{todo.task}</li>
      ))}
    </ul>
  );
}

Keys should NEVER be generated on the fly. Using key={Math.random()} or key={crypto.randomUUID()} *while* rendering the list defeats the purpose of the key, as now a new key will get created for every render of the list. Keys should always be inferred from the data directly. 


***You need to give each array item a key — a string or a number that uniquely identifies it among other items in that array: ***
<li key={person.id}>...</li>
JSX elements directly inside a map() call always need keys!
Keys tell React which array item each component corresponds to, so that it can match them up later. This becomes important if your array items can move (e.g. due to sorting), get inserted, or get deleted. A well-chosen key helps React infer what exactly has happened, and make the correct updates to the DOM tree. You should generate the keys directly in your data:
export const people = [{
  id: 0,         // Used in JSX as a key
  name: 'Creola Katherine Johnson',
  profession: 'mathematician',
  accomplishment: 'spaceflight calculations',
  imageId: 'MK3eW3A'
}...]

* What do you do when each item needs to render not one, but several DOM nodes? *
The short <>...</> Fragment syntax won’t let you pass a key, so you need to either group them into a single <div>, or use the slightly longer and more explicit <Fragment> syntax:

import { Fragment } from 'react';
// ...
const listItems = people.map(person =>
  <Fragment key={person.id}>
    <h1>{person.name}</h1>
    <p>{person.bio}</p>
  </Fragment>
);
Fragments disappear from the DOM, so this will produce a flat list of <h1>, <p>, <h1>, <p>, and so on.

Rules of keys:
Keys must be unique among siblings. However, it’s okay to use the same keys for JSX nodes in different arrays.
Keys must not change or that defeats their purpose! Don’t generate them while rendering.

You might be tempted to use an item’s index in the array as its key. In fact, that’s what React will use if you don’t specify a key at all. But the order in which you render items will change over time if an item is inserted, deleted, or if the array gets reordered. Index as a key often leads to subtle and confusing bugs.
Note that your components won’t receive key as a prop. It’s only used as a hint by React itself. If your component needs an ID, you have to pass it as a separate prop: 
<Profile key={id} userId={id} />.

Example: 
import { recipes } from './data.js';
function Recipe({ id, name, ingredients }) {
  return (
    <div>
      <h2>{name}</h2>
      <ul>
        {ingredients.map(ingredient =>
          <li key={ingredient}>
            {ingredient}
          </li>
        )}
      </ul>
    </div>
  );
}
export default function RecipeList() {
  return (
    <div>
      <h1>Recipes</h1>
      {recipes.map(recipe =>
        <Recipe {...recipe} key={recipe.id} />
      )}
    </div>
  );
}
^^^^^
Here, <Recipe {...recipe} key={recipe.id} /> is a syntax shortcut saying “pass all properties of the recipe object as props to the Recipe component”. You could also write each prop explicitly: <Recipe id={recipe.id} name={recipe.name} ingredients={recipe.ingredients} key={recipe.id} />.

Note that the key is specified on the <Recipe> itself rather than on the root <div> returned from Recipe. This is because this key is needed directly within the context of the surrounding array. Previously, you had an array of <div>s so each of them needed a key, but now you have an array of <Recipe>s. In other words, when you extract a component, don’t forget to leave the key outside the JSX you copy and paste.

import { Fragment } from 'react';

const poem = {
  lines: [
    'I write, erase, rewrite',
    'Erase again, and then',
    'A poppy blooms.'
  ]
};

export default function Poem() {
  return (
    <article>
      {poem.lines.map((line, i) =>
        <Fragment key={i}>
          {i > 0 && <hr />} // the objective was to insert a hr in-between lines of the poem
          <p>{line}</p>
        </Fragment>
      )}
    </article>
  );
}

